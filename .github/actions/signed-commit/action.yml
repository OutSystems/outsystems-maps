#
# This action enables to perform signed commits. 
# It imports the GPG key manually and sets up the git configuration for signing commits.
# The action then performs a signed git commit and push to the specified branch.
#
# HOW TO USE:
#
# To call this reusable action, copy the code between === lines to workflow file,
# uncomment and adjust "uses" as needed (use the latest tag available).
# ======================================================================
# on:
#
#     (...)
#     steps:
#     (...)
#       - name: Commit changes Signed
#         uses: OutSystems/rd.github-reusable-workflows/.github/actions/signed-commit@vTagVersion
#         with:
#           commit-branch: ${{ BRANCH_NAME }}
#           commit-message: ${{ COMMIT_MESSAGE }}
#           commit-new-files: ${{ true || false }}
#           gpg-priv-key: ${{ GPG_SIGN_KEY }}
#           gpg-pass-phrase: ${{ GPG_PASSPHRASE }}
#
# ======================================================================
#

name: Signed GPG Commit
description: 'Prepare and sign the commit signed'
inputs:
    commit-branch:
        description: 'Branch where to commit.'
        required: true
        default: ''
    commit-message:
        description: 'Commit message.'
        required: true
        default: ''
    commit-new-files:
        description: 'Defines if a `git add.` should be made or not.'
        required: false
        default: false
    gpg-priv-key:
        description: 'GPG Private key.'
        required: true
        default: ''
    gpg-pass-phrase:
        description: 'GPG passphrase.'
        required: false
        default: '""'

runs:
    using: composite
    steps:
        - name: Configure GPG for non-interactive use
          shell: bash
          run: |
              mkdir -p ~/.gnupg
              chmod 700 ~/.gnupg
              cat > ~/.gnupg/gpg-agent.conf << EOF
              allow-loopback-pinentry
              allow-preset-passphrase
              EOF
              cat > ~/.gnupg/gpg.conf << EOF
              pinentry-mode loopback
              use-agent
              EOF
              chmod 600 ~/.gnupg/gpg-agent.conf ~/.gnupg/gpg.conf
              gpgconf --kill gpg-agent || true
              gpg-connect-agent reloadagent /bye || true

        - name: Import GPG key and configure git
          shell: bash
          env:
              GPG_PRIVATE_KEY: ${{ inputs.gpg-priv-key }}
          run: |
              # Import the key and capture the fingerprint of the imported key
              IMPORT_OUTPUT=$(echo "$GPG_PRIVATE_KEY" | gpg --batch --import --import-options show-only --with-colons 2>/dev/null | grep fpr | head -1 | cut -d':' -f10)
              echo "$GPG_PRIVATE_KEY" | gpg --batch --import
              
              # Use the fingerprint from import, or fall back to first secret key
              if [ -n "$IMPORT_OUTPUT" ]; then
                  FINGERPRINT="$IMPORT_OUTPUT"
              else
                  FINGERPRINT=$(gpg --list-secret-keys --with-colons | grep fpr | head -1 | cut -d':' -f10)
              fi
              
              # Key ID is the last 16 characters of fingerprint
              KEY_ID="${FINGERPRINT: -16}"
              
              # Get user identity using machine-readable format (uid line, field 10 contains the user ID string)
              USER_ID=$(gpg --list-secret-keys --with-colons "$FINGERPRINT" | grep uid | head -1 | cut -d':' -f10)
              
              # Parse email and name from USER_ID (format: "Name <email>")
              if [[ "$USER_ID" =~ \<([^>]+)\> ]]; then
                  USER_EMAIL="${BASH_REMATCH[1]}"
              else
                  USER_EMAIL=""
              fi
              USER_NAME=$(echo "$USER_ID" | sed 's/ <.*//')
              
              # Configure git to use this key for signing
              git config --global user.signingkey "$KEY_ID"
              git config --global commit.gpgsign true
              git config --global gpg.program gpg
              
              # Configure git user from the key
              if [ -n "$USER_EMAIL" ]; then
                  git config --global user.email "$USER_EMAIL"
              fi
              if [ -n "$USER_NAME" ]; then
                  git config --global user.name "$USER_NAME"
              fi
              
              # Trust the key ultimately (6 = ultimate trust)
              echo "${FINGERPRINT}:6:" | gpg --import-ownertrust

        - name: Add new files (if needed)
          shell: bash
          if: ${{ inputs.commit-new-files == 'true' }}
          run: |
              git add .

        - name: Commit and push
          shell: bash
          env:
              GPG_PASSPHRASE: ${{ inputs.gpg-pass-phrase }}
          run: |
              # Get the key ID and keygrip using machine-readable format
              KEY_ID=$(git config --get user.signingkey)
              KEYGRIP=$(gpg --list-secret-keys --with-colons --with-keygrip "$KEY_ID" | grep grp | head -1 | cut -d':' -f10)
              
              # Ensure gpg-agent is running with correct config
              gpgconf --kill gpg-agent || true
              gpg-connect-agent /bye || true
              
              # Preset the passphrase in gpg-agent using gpg-connect-agent (portable approach)
              if [ -n "$GPG_PASSPHRASE" ] && [ "$GPG_PASSPHRASE" != '""' ] && [ -n "$KEYGRIP" ]; then
                  # Convert passphrase to hex for gpg-connect-agent
                  PASSPHRASE_HEX=$(echo -n "$GPG_PASSPHRASE" | xxd -p -c 256 | tr -d '\n')
                  gpg-connect-agent "PRESET_PASSPHRASE $KEYGRIP -1 $PASSPHRASE_HEX" /bye
              fi
              
              git commit -m "${{ inputs.commit-message }}"
              git push origin ${{ inputs.commit-branch }}
