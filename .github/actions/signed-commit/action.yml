#
# This action enables to perform signed commits. 
# It imports the GPG key manually and sets up the git configuration for signing commits.
# The action then performs a signed git commit and push to the specified branch.
#
# HOW TO USE:
#
# To call this reusable action, copy the code between === lines to workflow file,
# uncomment and adjust "uses" as needed (use the latest tag available).
# ======================================================================
# on:
#
#     (...)
#     steps:
#     (...)
#       - name: Commit changes Signed
#         uses: OutSystems/rd.github-reusable-workflows/.github/actions/signed-commit@vTagVersion
#         with:
#           commit-branch: ${{ BRANCH_NAME }}
#           commit-message: ${{ COMMIT_MESSAGE }}
#           commit-new-files: ${{ true || false }}
#           gpg-priv-key: ${{ GPG_SIGN_KEY }}
#           gpg-pass-phrase: ${{ GPG_PASSPHRASE }}
#           gpg-passphrase-timeout: ${{ GPG_PASSPHRASE_TIMEOUT }}  # Optional: default 300 seconds
#
# ======================================================================
#

name: Signed GPG Commit
description: 'Prepare and sign the commit signed'
inputs:
    commit-branch:
        description: 'Branch where to commit.'
        required: true
        default: ''
    commit-message:
        description: 'Commit message.'
        required: true
        default: ''
    commit-new-files:
        description: 'Defines if a `git add.` should be made or not.'
        required: false
        default: false
    gpg-priv-key:
        description: 'GPG Private key.'
        required: true
        default: ''
    gpg-pass-phrase:
        description: 'GPG passphrase.'
        required: false
        default: '""'
    gpg-passphrase-timeout:
        description: 'GPG passphrase cache timeout in seconds. Use -1 for no expiration (not recommended for self-hosted runners). Default: 300 (5 minutes).'
        required: false
        default: '300'

runs:
    using: composite
    steps:
        # ============================================================
        # STEP 1: Configure GPG for non-interactive (CI) use
        # ============================================================
        # GPG by default expects a TTY for passphrase input. In CI environments,
        # there's no TTY, so we configure GPG to use "loopback" pinentry mode
        # which allows passphrase to be provided programmatically.
        # 
        # Security: Use an isolated GNUPGHOME under $RUNNER_TEMP to avoid
        # persisting keys/config in ~/.gnupg on self-hosted runners.
        - name: Configure GPG for non-interactive use
          shell: bash
          run: |
              # Create isolated GPG home directory under runner temp with secure permissions
              # This prevents key/config persistence on self-hosted runners
              export GNUPGHOME="${RUNNER_TEMP}/gnupg-$$"
              mkdir -p "$GNUPGHOME"
              chmod 700 "$GNUPGHOME"
              
              # Persist GNUPGHOME for subsequent steps
              echo "GNUPGHOME=$GNUPGHOME" >> "$GITHUB_ENV"
              
              # Configure gpg-agent:
              # - allow-loopback-pinentry: Allows passphrase input via loopback (not TTY)
              # - allow-preset-passphrase: Allows caching passphrase before it's needed
              cat > "$GNUPGHOME/gpg-agent.conf" << EOF
              allow-loopback-pinentry
              allow-preset-passphrase
              EOF
              
              # Configure gpg:
              # - pinentry-mode loopback: Use loopback for passphrase (no TTY prompt)
              # - use-agent: Use gpg-agent for key operations
              cat > "$GNUPGHOME/gpg.conf" << EOF
              pinentry-mode loopback
              use-agent
              EOF
              
              # Set secure permissions on config files
              chmod 600 "$GNUPGHOME/gpg-agent.conf" "$GNUPGHOME/gpg.conf"
              
              # Create a GPG wrapper script that always uses loopback pinentry mode
              # This ensures GPG never tries to access /dev/tty regardless of how it's invoked
              GPG_WRAPPER="$GNUPGHOME/gpg-wrapper.sh"
              printf '%s\n' '#!/bin/bash' 'exec gpg --pinentry-mode loopback "$@"' > "$GPG_WRAPPER"
              chmod 755 "$GPG_WRAPPER"
              
              # Export wrapper path for git to use
              echo "GPG_WRAPPER=$GPG_WRAPPER" >> "$GITHUB_ENV"
              
              # Restart gpg-agent to pick up new configuration
              # || true prevents failure if agent wasn't running
              gpgconf --kill gpg-agent || true
              gpg-connect-agent reloadagent /bye || true

        # ============================================================
        # STEP 2: Validate inputs
        # ============================================================
        # Validate required inputs early to provide clear error messages.
        - name: Validate inputs
          shell: bash
          env:
              GPG_PRIVATE_KEY: ${{ inputs.gpg-priv-key }}
              COMMIT_BRANCH: ${{ inputs.commit-branch }}
              COMMIT_MESSAGE: ${{ inputs.commit-message }}
          run: |
              # Validate GPG private key is not empty
              if [ -z "$GPG_PRIVATE_KEY" ]; then
                  echo "::error::GPG private key is empty. Please provide a valid GPG private key."
                  exit 1
              fi
              
              # Validate commit branch is not empty
              if [ -z "$COMMIT_BRANCH" ]; then
                  echo "::error::Commit branch is empty. Please specify a target branch."
                  exit 1
              fi
              
              # Validate commit message is not empty
              if [ -z "$COMMIT_MESSAGE" ]; then
                  echo "::error::Commit message is empty. Please provide a commit message."
                  exit 1
              fi

        # ============================================================
        # STEP 3: Import GPG key and configure Git for signing
        # ============================================================
        # This step imports the provided GPG private key, extracts its
        # fingerprint and user identity, then configures Git to use it
        # for commit signing.
        - name: Import GPG key and configure git
          shell: bash
          env:
              # Pass the private key via environment variable to avoid shell escaping issues
              GPG_PRIVATE_KEY: ${{ inputs.gpg-priv-key }}
          run: |
              # ----------------------------------------------------------
              # Extract fingerprint from the key BEFORE importing
              # ----------------------------------------------------------
              # Using --import-options show-only displays key info without importing.
              # --with-colons outputs machine-readable format (not locale-dependent).
              # The 'fpr' line contains the fingerprint in field 10.
              # { grep fpr || true; } prevents pipeline failure if no match (pipefail safe).
              # Using printf '%s' instead of echo to avoid escape sequence interpretation
              # and preserve exact multi-line armored key contents.
              # --pinentry-mode loopback: Explicitly set on command line for reliability.
              IMPORT_OUTPUT=$(printf '%s' "$GPG_PRIVATE_KEY" | gpg --batch --pinentry-mode loopback --import --import-options show-only --with-colons 2>/dev/null | { grep fpr || true; } | head -1 | cut -d':' -f10)
              
              # ----------------------------------------------------------
              # Actually import the key into the keyring
              # ----------------------------------------------------------
              # --batch: Non-interactive mode, no prompts
              # --pinentry-mode loopback: Prevents TTY prompts in CI environments
              # Using printf '%s' to preserve exact key contents (avoid echo escape sequences)
              printf '%s' "$GPG_PRIVATE_KEY" | gpg --batch --pinentry-mode loopback --import
              
              # ----------------------------------------------------------
              # Determine the fingerprint to use
              # ----------------------------------------------------------
              # Prefer the fingerprint from show-only (identifies exact key imported).
              # Fall back to first secret key if show-only didn't work.
              if [ -n "$IMPORT_OUTPUT" ]; then
                  FINGERPRINT="$IMPORT_OUTPUT"
              else
                  FINGERPRINT=$(gpg --list-secret-keys --with-colons | { grep fpr || true; } | head -1 | cut -d':' -f10)
              fi
              
              # ----------------------------------------------------------
              # Validate we got a fingerprint
              # ----------------------------------------------------------
              # Without a fingerprint, we can't configure signing - fail explicitly.
              if [ -z "$FINGERPRINT" ]; then
                  echo "::error::Failed to extract GPG key fingerprint"
                  exit 1
              fi
              
              # ----------------------------------------------------------
              # Extract user identity from the key
              # ----------------------------------------------------------
              # The 'uid' line in --with-colons format contains the user ID in field 10.
              # Format is typically: "Real Name <email@example.com>"
              USER_ID=$(gpg --list-secret-keys --with-colons "$FINGERPRINT" | { grep uid || true; } | head -1 | cut -d':' -f10)
              
              # Parse email (inside angle brackets) and name (before angle brackets)
              USER_EMAIL=""
              USER_NAME=""
              if [ -n "$USER_ID" ]; then
                  # Extract email using regex: match content between < and >
                  if [[ "$USER_ID" =~ \<([^>]+)\> ]]; then
                      USER_EMAIL="${BASH_REMATCH[1]}"
                  fi
                  # Extract name: everything before " <"
                  USER_NAME=$(echo "$USER_ID" | sed 's/ <.*//')
              fi
              
              # ----------------------------------------------------------
              # Configure Git for GPG signing
              # ----------------------------------------------------------
              # Use full fingerprint (40 chars) for unambiguous key identification.
              # Short key IDs can collide when multiple keys exist.
              # Using --local to avoid persisting config on self-hosted runners.
              git config --local user.signingkey "$FINGERPRINT"
              git config --local commit.gpgsign true
              
              # Use the GPG wrapper script that enforces loopback pinentry mode
              # This prevents "cannot open /dev/tty" errors in CI environments
              if [ -n "$GPG_WRAPPER" ] && [ -x "$GPG_WRAPPER" ]; then
                  git config --local gpg.program "$GPG_WRAPPER"
              else
                  git config --local gpg.program gpg
              fi
              
              # Set Git user identity from the GPG key (if extracted)
              if [ -n "$USER_EMAIL" ]; then
                  git config --local user.email "$USER_EMAIL"
              fi
              if [ -n "$USER_NAME" ]; then
                  git config --local user.name "$USER_NAME"
              fi

        # ============================================================
        # STEP 4: Stage new files (optional)
        # ============================================================
        # If commit-new-files is true, stage all changes including new files.
        - name: Add new files (if needed)
          shell: bash
          if: ${{ inputs.commit-new-files == 'true' }}
          run: |
              git add .

        # ============================================================
        # STEP 5: Preset passphrase, commit, and push
        # ============================================================
        # This step caches the passphrase in gpg-agent so GPG can sign
        # without prompting, then creates the signed commit and pushes.
        - name: Commit and push
          shell: bash
          env:
              # Pass passphrase via environment variable for security
              GPG_PASSPHRASE: ${{ inputs.gpg-pass-phrase }}
              # Unset GPG_TTY to prevent GPG from trying to use a terminal
              GPG_TTY: ""
          run: |
              # ----------------------------------------------------------
              # Get the signing key and its keygrip
              # ----------------------------------------------------------
              # Keygrip is a unique identifier for the key's cryptographic material,
              # used by gpg-agent for passphrase caching.
              SIGNING_KEY=$(git config --get user.signingkey)
              
              # Extract keygrip from machine-readable output.
              # 'grp' line contains the keygrip in field 10.
              KEYGRIP=$(gpg --list-secret-keys --with-colons --with-keygrip "$SIGNING_KEY" | { grep grp || true; } | head -1 | cut -d':' -f10)
              KEYGRIP="${KEYGRIP:-}"  # Ensure variable is defined (empty if not found)
              
              # ----------------------------------------------------------
              # Restart gpg-agent with our configuration
              # ----------------------------------------------------------
              # Kill and restart to ensure agent uses our allow-preset-passphrase config.
              gpgconf --kill gpg-agent || true
              gpg-connect-agent /bye || true  # /bye starts agent and immediately disconnects
              
              # ----------------------------------------------------------
              # Preset (cache) the passphrase in gpg-agent
              # ----------------------------------------------------------
              # This allows GPG to sign without prompting for the passphrase.
              # Only do this if we have a passphrase and a valid keygrip.
              if [ -n "$GPG_PASSPHRASE" ] && [ "$GPG_PASSPHRASE" != '""' ] && [ -n "$KEYGRIP" ]; then
                  # gpg-connect-agent expects passphrase in hexadecimal format.
                  # Using printf '%s' to avoid echo interpreting escape sequences in passphrase.
                  # xxd -p: Convert to plain hex dump
                  # -c 256: Output all on one line (up to 256 bytes)
                  # tr -d '\n': Remove any newlines
                  PASSPHRASE_HEX=$(printf '%s' "$GPG_PASSPHRASE" | xxd -p -c 256 | tr -d '\n')
                  
                  # PRESET_PASSPHRASE command format:
                  # PRESET_PASSPHRASE <keygrip> <timeout> <hex-passphrase>
                  # timeout in seconds: -1 = no expiration (cached until agent restarts)
                  # Use configurable timeout to limit passphrase exposure on self-hosted runners
                  gpg-connect-agent "PRESET_PASSPHRASE $KEYGRIP ${{ inputs.gpg-passphrase-timeout }} $PASSPHRASE_HEX" /bye
              fi
              
              # ----------------------------------------------------------
              # Create signed commit and push
              # ----------------------------------------------------------
              # Git will automatically use GPG to sign (commit.gpgsign = true)
              # and will use the cached passphrase from gpg-agent.
              git commit -m "${{ inputs.commit-message }}"
              git push origin -- "${{ inputs.commit-branch }}"

        # ============================================================
        # STEP 6: Cleanup GPG environment
        # ============================================================
        # Remove the isolated GNUPGHOME to prevent key/config persistence
        # on self-hosted runners and avoid cross-job leakage.
        - name: Cleanup GPG environment
          shell: bash
          if: always()
          run: |
              # Only kill gpg-agent if GNUPGHOME is set to avoid killing default agent
              # on self-hosted runners. Use --homedir to target the isolated keyring.
              if [ -n "$GNUPGHOME" ] && [ -d "$GNUPGHOME" ]; then
                  gpgconf --homedir "$GNUPGHOME" --kill gpg-agent || true
                  
                  # Remove the isolated GNUPGHOME directory
                  rm -rf "$GNUPGHOME"
              fi
